<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JS高级笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JS高级进阶内置对象与方法(基础复习)Array对象 属性: length 设置或返回数组中元素的数目   方法: concat()            连接两个或更多的数组,并返回结果 join()              将数组拼接成字符串 pop()               删除并返回数组的最后一个元素 push()              向数组的末尾添加元素,并返回新的长度 r">
<meta name="keywords" content="JS高级学习">
<meta property="og:type" content="article">
<meta property="og:title" content="JS高级笔记">
<meta property="og:url" content="http://yoursite.com/2016/04/07/JS高级笔记/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JS高级进阶内置对象与方法(基础复习)Array对象 属性: length 设置或返回数组中元素的数目   方法: concat()            连接两个或更多的数组,并返回结果 join()              将数组拼接成字符串 pop()               删除并返回数组的最后一个元素 push()              向数组的末尾添加元素,并返回新的长度 r">
<meta property="og:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/01-2.png">
<meta property="og:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/01-3.png">
<meta property="og:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/02-4.png">
<meta property="og:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/02-5.png">
<meta property="og:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/01-1.jpg">
<meta property="og:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/06-1.png">
<meta property="og:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/11.png">
<meta property="og:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/12.png">
<meta property="og:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/13.png">
<meta property="og:updated_time" content="2018-04-07T09:01:00.919Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS高级笔记">
<meta name="twitter:description" content="JS高级进阶内置对象与方法(基础复习)Array对象 属性: length 设置或返回数组中元素的数目   方法: concat()            连接两个或更多的数组,并返回结果 join()              将数组拼接成字符串 pop()               删除并返回数组的最后一个元素 push()              向数组的末尾添加元素,并返回新的长度 r">
<meta name="twitter:image" content="http://yoursite.com/2016/04/07/JS高级笔记/images/01-2.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JS高级笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/JS高级笔记/" class="article-date">
  <time datetime="2016-04-07T08:59:47.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JS高级笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS高级进阶"><a href="#JS高级进阶" class="headerlink" title="JS高级进阶"></a>JS高级进阶</h1><h2 id="内置对象与方法-基础复习"><a href="#内置对象与方法-基础复习" class="headerlink" title="内置对象与方法(基础复习)"></a>内置对象与方法(基础复习)</h2><h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><ul>
<li>属性: length 设置或返回数组中元素的数目</li>
</ul>
<ul>
<li>方法:<ul>
<li>concat()            连接两个或更多的数组,并返回结果</li>
<li>join()              将数组拼接成字符串</li>
<li>pop()               删除并返回数组的最后一个元素</li>
<li>push()              向数组的末尾添加元素,并返回新的长度</li>
<li>reverse()           翻转数组</li>
<li>shift()             删除并返回数组的第一个元素</li>
<li>unshift()           向数组的开头添加元素, 并返回新的长度</li>
<li>slice()             从某个已有的数组返回选定的元素(截取)</li>
<li>sort()              排序</li>
<li>splice()            删除元素, 并向数组添加新元素</li>
</ul>
</li>
</ul>
<h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><ul>
<li>方法:<ul>
<li>new Date()          返回当前的日期和时间</li>
<li>getDate()           从 Date 对象返回一个月中的某一天 (1 ~ 31)</li>
<li>getDay()            从 Date 对象返回星期 (0 ~ 6)</li>
<li>getMonth ()         从 Date 对象返回月份 (0 ~ 11)</li>
<li>getFullYear()       从 Date 对象以四位数字返回年份</li>
<li>getHours()          返回 Date 对象的小时 (0 ~ 23)</li>
<li>getMinutes()        返回 Date 对象的分钟 (0 ~ 59)</li>
<li>getSeconds()        返回 Date 对象的秒数 (0 ~ 59)</li>
<li>getMilliseconds()   返回 Date 对象的毫秒 (0 ~ 999)</li>
</ul>
</li>
</ul>
<h3 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h3><ul>
<li>方法:<ul>
<li>toString            把数字转换为字符串，使用指定的基数</li>
<li>toFixed             把数字转换为字符串，结果的小数点后有指定位数的数字</li>
<li>toExponential       把对象的值转换为指数计数法</li>
<li>toPrecision         把数字格式化为指定的长度</li>
<li>valueOf             返回一个 Number 对象的基本数字值</li>
</ul>
</li>
</ul>
<h3 id="Boolean对象"><a href="#Boolean对象" class="headerlink" title="Boolean对象"></a>Boolean对象</h3><ul>
<li>方法<ul>
<li>toString()          把逻辑值转化为字符串, 并返回结果</li>
<li>valueOf()           返回Boolean对象的原始值</li>
</ul>
</li>
</ul>
<h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><ul>
<li>属性: length  字符串的长度</li>
<li><p>方法:</p>
<ul>
<li>sub()                把字符串显示为下标</li>
<li>charAt()             返回在指定位置的字符</li>
<li>concat()             连接字符串</li>
<li>indexOf()            检索字符串</li>
<li>replace()            替换与正则表达式匹配的子串</li>
<li>search()             检索与正则表达式相匹配的值</li>
<li><p>slice()              一个参数时，从这个索引开始的位置截取到最后一个并返回，两个参数时，第一个是开头，                                               第二个是结尾（不包括结尾）</p>
</li>
<li><p>split()              把字符串分割为字符串数组</p>
</li>
<li>substr()             从起始索引号提取字符串中指定数目的字符</li>
<li>substring()          提取字符串中两个指定的索引号之间的字符</li>
<li>toString()           返回字符串</li>
<li>valueOf()            返回某个字符串对象的原始值 </li>
</ul>
</li>
</ul>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><ul>
<li>方法:<ul>
<li>abs(x)               返回数的绝对值</li>
<li>ceil(x)              向上取舍</li>
<li>floor(x)             向下取舍</li>
<li>max(x,y)             返回x和y中的最大值</li>
<li>min(x,y)             返回x和y中的最小值</li>
<li>pow(x,y)             返回x的y次幂</li>
<li>random(x,y)          返回0-1之间的随机数</li>
</ul>
</li>
</ul>
<h2 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h2><h3 id="值类型-基本类型"><a href="#值类型-基本类型" class="headerlink" title="值类型(基本类型)"></a>值类型(基本类型)</h3><ul>
<li>数值类型</li>
<li>布尔类型</li>
<li>undefined</li>
<li>null</li>
<li>字符串</li>
</ul>
<p><strong>注</strong>: 值类型存储在栈(stack)中的简单数据, 他们的值直接存储在变量访问的位置</p>
<ul>
<li>上面定义的这些值类型的数据在内存中的存储如下:<br><img src="images/01-2.png" alt="图示"></li>
</ul>
<h3 id="引用类型-复合类型"><a href="#引用类型-复合类型" class="headerlink" title="引用类型(复合类型)"></a>引用类型(复合类型)</h3><ul>
<li>Object</li>
<li>Array</li>
<li>Function</li>
<li>Date</li>
<li>Math</li>
<li>RegExp</li>
<li>String</li>
<li>Number</li>
<li><p>Boolean</p>
</li>
<li><p>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处<br><img src="images/01-3.png" alt="图示"></p>
</li>
</ul>
<h3 id="值类型与引用类型的特征"><a href="#值类型与引用类型的特征" class="headerlink" title="值类型与引用类型的特征"></a>值类型与引用类型的特征</h3><h4 id="值类型赋值-直接将值复制一份"><a href="#值类型赋值-直接将值复制一份" class="headerlink" title="值类型赋值, 直接将值复制一份"></a>值类型赋值, 直接将值复制一份</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1=<span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> num2=num1;</div></pre></td></tr></table></figure>
<ul>
<li>上述代码的过程<br><img src="images/02-4.png" alt="图示"><ul>
<li><code>var num1=10</code>表示变量num1存储的数字10</li>
<li>将数据拷贝一份, 也就是将10拷贝一份, 这时内存中有两个10</li>
<li>将拷贝的10赋值给num2</li>
</ul>
</li>
</ul>
<h4 id="引用类型赋值-是将地址复制一份"><a href="#引用类型赋值-是将地址复制一份" class="headerlink" title="引用类型赋值, 是将地址复制一份"></a>引用类型赋值, 是将地址复制一份</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>:<span class="string">"zs"</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;;</div><div class="line"><span class="keyword">var</span> p1 = p;</div></pre></td></tr></table></figure>
<ul>
<li>上述代码的过程:<br><img src="images/02-5.png" alt="图示"><ul>
<li><code>var p = {name:&quot;zs&quot;,age:19}</code>; p中存储的是对象的地址</li>
<li>赋值就是将变量p中存储的数据, 也就是地址拷贝一份, 然后将数据赋值给p1</li>
<li>此时内存中只有一个对象, 变量p和p1同时指向这个对象</li>
</ul>
</li>
</ul>
<p><strong>问题</strong>: 利用p1修改的name属性会影响到p中的name  </p>
<h3 id="值类型与引用类型做参数"><a href="#值类型与引用类型做参数" class="headerlink" title="值类型与引用类型做参数"></a>值类型与引用类型做参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    num++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">foo(a);</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    o.age++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>:<span class="string">"张三"</span>, <span class="attr">age</span>:<span class="number">19</span>&#125;;</div><div class="line"></div><div class="line">foo(p);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p.age);</div></pre></td></tr></table></figure>
<ul>
<li><strong>总结</strong>:<ul>
<li>在调用函数的时候, 传参的过程其实就是用实参给形参赋值的过程</li>
<li>当参数为值类型时, 函数内和函数外的两个变量完全不同, 仅仅是存的值相同, 修改时互不影响</li>
<li>当参数为引用类型时, 函数内和函数外的两个变量不同, 但是共同指向同一个对象, 在函数内修改对象数据时会影响到外部</li>
</ul>
</li>
</ul>
<h2 id="对象的动态特性"><a href="#对象的动态特性" class="headerlink" title="对象的动态特性"></a>对象的动态特性</h2><h3 id="给对象动态添加属性"><a href="#给对象动态添加属性" class="headerlink" title="给对象动态添加属性"></a>给对象动态添加属性</h3><ul>
<li>当一个对象需要某个属性时, 可以用两种方式为其添加属性<ul>
<li>直接使用<code>对象名.属性名 = 值</code>这种形式来添加</li>
<li>使用关联数组语法<code>对象名[&quot;属性名&quot;] = 值</code> 来添加  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//o是一个没有任何自定义属性的对象</span></div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="comment">//现在想让他拥有name age gender等属性</span></div><div class="line"><span class="comment">//直接使用 对象名.属性名 = 值</span></div><div class="line">o.name = <span class="string">"张三"</span>;</div><div class="line"><span class="comment">//使用 对象名["属性名"] = 值</span></div><div class="line">o[<span class="string">"age"</span>] = <span class="number">18</span>;</div><div class="line"><span class="comment">//可以通过打印查看效果</span></div><div class="line"><span class="built_in">console</span>.log(o.name);</div><div class="line"><span class="built_in">console</span>.log(o.age);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>: 当要动态的为一个对象添加属性时, 必须使用关联数组的方式(即方括号语法)</p>
<h3 id="对象属性的访问形式"><a href="#对象属性的访问形式" class="headerlink" title="对象属性的访问形式"></a>对象属性的访问形式</h3><ul>
<li>两种方式:<ul>
<li>点语法: <code>对象名.属性名</code></li>
<li>关联数组: <code>对象名[属性名]</code>　</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    name:<span class="string">"张三"</span>,</div><div class="line">    sayHello:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"你好，我叫"</span>+ <span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//点语法</span></div><div class="line"><span class="built_in">console</span>.log(o.name);</div><div class="line"><span class="comment">//关联数组语法</span></div><div class="line"><span class="built_in">console</span>.log(o[<span class="string">"name"</span>]);</div><div class="line"><span class="comment">//这两种用法同样适用于方法</span></div><div class="line">o.sayHello();</div><div class="line">o[<span class="string">"sayHello"</span>]();</div><div class="line"><span class="comment">//可以对这个对象的属性进行遍历，如果是值就打印，如果是方法就调用</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o)&#123;</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> o[ k ] == <span class="string">'function'</span> ) &#123;</div><div class="line">        o[ k ]();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'log: '</span> + o[ k ] );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h3><ul>
<li>逐语句: 代码会一句一句的执行 , 遇到方法会进入方法体的内部 ,逐句执行每一行的代码 (能看到方法中的每一段代码)</li>
<li><p>逐过程: 将方法中的代码 看做一行代码 进行执行</p>
</li>
<li><p>断点: 程序执行到此会暂停</p>
</li>
<li><p>条件断点 : 满足条件 则暂停    不满足  就继续  (右键点击断点处 ,选择 Addconditional breakpoint)</p>
</li>
<li><p>异常处理 : 提高程序的健壮性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  基本语法 :   </span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 写可能出现错误的代码</span></div><div class="line">               &#125; <span class="keyword">catch</span> (e) &#123;    <span class="comment">// 异常对象: e中包含有异常的相关信息</span></div><div class="line">                <span class="comment">// 处理错误的代码  (注:代码出错才执行)</span></div><div class="line">               &#125;<span class="keyword">finally</span>&#123;</div><div class="line">                <span class="comment">// 写最后执行的代码 </span></div><div class="line">                <span class="comment">// (注:无论有没有错误 , 都会执行该代码 ; js中很少用  , 一般用于后台开发, 多用于 在程序执行结束时 ,清理内存,垃圾回收)</span></div><div class="line">            &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>try – catch 的执行过程:<ul>
<li>如果try中的代码没有出错 ,catch中的处理错误代码就不会执行</li>
<li>如果try 中代码出现了错误 ,try 中 出现错误之后的代码就不会执行 ,直接跳转到catch中, 不会影响下面代码的执行<br><strong>注</strong>: throw 用来抛出错误(可以自定义) 可以抛任何数据 , 抛出的是什么类型的异常(或错误), e异常对象捕获的就是什么类型  ; 用e 来捕获</li>
</ul>
</li>
</ul>
<h2 id="与"><a href="#与" class="headerlink" title="== 与 ==="></a>== 与 ===</h2><h3 id="只判断值是否相等"><a href="#只判断值是否相等" class="headerlink" title="== : 只判断值是否相等"></a>== : 只判断值是否相等</h3><p><strong>注</strong>: 如果两个是引用类型,直接比较地址 如: console.log({} == {}) 结果为false 因为两者的地址不一样</p>
<ul>
<li>==的比较规则:</li>
</ul>
<ol>
<li>==两边的类型必须一致 , 如果不一样 , 要进行类型转换 , 转换成一致的<br>2.如果两个是引用类型 , 比较地址 , 如果是值类型 , 直接比较值<br>3.如果 == 两边 一个是值类型 , 一个是引用类型 , 则会把引用类型转换成值类型 , 再进行比较 </li>
</ol>
<ul>
<li>引用类型转换成值类型的规则:</li>
</ul>
<ol>
<li>会首先调用 对象的 valueOf ( )  方法 ,会得到一个结果 ,如果是值类型的 , 就直接进行比较</li>
<li>如果 valueOf () 的结果不是值类型的 , 会调用 对象的 toString () , 会得到一个字符串的类型的数据 , 再进行比较</li>
</ol>
<ul>
<li>== 两边都是值类型  比较规则 : </li>
</ul>
<ol>
<li>默认 null == undefined 结果为true</li>
<li>如果 == 两边有布尔类型的值 先将true 转为 1  false转为 0 再进行比较</li>
<li>如果一边是数字 , 一边是字符串 会将字符串转为数字再进行比较</li>
</ol>
<h3 id="判断值和类型是否相等"><a href="#判断值和类型是否相等" class="headerlink" title="=== : 判断值和类型是否相等"></a>=== : 判断值和类型是否相等</h3><h2 id="in运算符与delete运算符"><a href="#in运算符与delete运算符" class="headerlink" title="in运算符与delete运算符"></a>in运算符与delete运算符</h2><h3 id="in运算符作用"><a href="#in运算符作用" class="headerlink" title="in运算符作用"></a>in运算符作用</h3><ul>
<li>For in  遍历对象 的成员</li>
<li>in  判断对象是否拥有指定属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'李 '</span> , <span class="attr">age</span> : <span class="number">18</span> &#125;   <span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> obj )  </div><div class="line"><span class="comment">// 结果为true ;  判断obj是否有这个属性, 结果为布尔类型</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="delete运算符作用"><a href="#delete运算符作用" class="headerlink" title="delete运算符作用"></a>delete运算符作用</h3><ul>
<li><p>可以删除未使用 var 声明 的变量 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">100</span> <span class="built_in">console</span>.log(<span class="keyword">delete</span> num)   <span class="comment">//删除失败 , 结果为false</span></div><div class="line">num1 = <span class="number">200</span>  <span class="built_in">console</span>.log(<span class="keyword">delete</span> num1)    <span class="comment">//结果为true</span></div></pre></td></tr></table></figure>
</li>
<li><p>可以删除对象的属性 (有或没有该属性 删除该属性的结果都为true)<br>结果 : true   false</p>
</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul>
<li>面向过程关注的实现功能的步骤，是如何把功能拆解后一步步的实现</li>
<li>面向对象则是关注的实现功能的一系列的对象<br><img src="images/01-1.jpg" alt="图解"></li>
</ul>
<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><ul>
<li>对象就是将数据与功能组合到一起, 就是封装</li>
</ul>
<ul>
<li>对象就是键值对的集合<ul>
<li>键值如果是数据(基本,复合,空数据), 就称为属性</li>
<li>如果键值是函数, 就称为方法</li>
</ul>
</li>
<li>对象就是将属性与方法封装起来</li>
<li>方法就是将过程封装起来</li>
</ul>
<ul>
<li><p>js中对象本身就是对象属性和方法的封装(将属性和方法封装成一个对象 , 实现一系列功能 , 只需要对外界暴露一些接口 , 外界在使用对象的时候 , 不需要关心对象的内部的功能实现)</p>
</li>
<li><p>问题: 定义在全局的方法 可能会 造成全局污染</p>
</li>
<li>解决: 使用命名空间(本质上就是一个对象)  避免全局污染 <pre><code>Js中继承 : 一个对象用于一些属性和方法 ,另一个对象也想拥有,可以通过继承来实现
</code></pre></li>
</ul>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ul>
<li>传统继承基于模板<ul>
<li>子类可以使用从父类继承的属性和方法</li>
<li>让某个类型的对象获得另一个类型的对象的属性和方法</li>
</ul>
</li>
<li>js继承基于对象<ul>
<li>在JS中, 继承就是当前对象可以使用其他对象的方法和属性</li>
</ul>
</li>
</ul>
<h3 id="多态性-基于强类型"><a href="#多态性-基于强类型" class="headerlink" title="多态性(基于强类型)"></a>多态性(基于强类型)</h3><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><ul>
<li>字面量</li>
<li>使用内置的构造函数Object() 配合new<br>缺点:代码复用性太差 ,每次创建对象都需要手动的添加</li>
<li>自定义构造函数</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//断点调试，进行类型查看</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure>
<h3 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h3><ul>
<li><p>构造函数是一个函数 , 一般用来初始化对象</p>
</li>
<li><p>特点:</p>
</li>
</ul>
<ol>
<li>构造函数的函数名首字母大写</li>
<li>构造函数 要配合new 关键字进行使用</li>
<li>构造函数中this 指向新创建的对象</li>
<li>不需要手动书写return语句 ,会默认返回新创建出来的对象<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//执行过程: (1) 首先使用new关键字 会开辟内存空间 , 创建新的对象 , 并且会用函数内部this指向空对象</span></div><div class="line"><span class="comment">// (2)构造函数开始执行 , 开始给this指向的空对象进行赋值</span></div><div class="line"><span class="comment">// (3) 当构造函数执行完成时, 会将新创建的对象当做返回值进行返回</span></div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>注意点: </p>
<ul>
<li><p>构造函数也是函数, 如果写了返回值(return) ,要判断值得类型 , 若是值类型 ,对结果没有影响 ,还是返回默认的新创建的对象; 若是引用类型 ,会用引用类型的数据去替换新创建的对象</p>
</li>
<li><p>构造函数可以当做普通函数执行 , 但是此时 函数内部的this 指向的是window</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>构造函数创建对象的性能问题: </p>
<ul>
<li><p>解决方案(让所有对象供用一个方法即可,即原型)</p>
<ul>
<li><p>通过new 关键字创建的对象 , 每个对象都会单独开辟内存空间 , 包含对象的方法也会单独开辟空间;</p>
</li>
<li><p>每个对象的属性 的取值是不同的 ,是特有的,但是 所有对象的方法的代码是一样的 , 可以共享一份 ; 但是构造函数会给每个对象的方法单独开辟空间 , 造成了内存浪费问题;</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="构造函数的作用"><a href="#构造函数的作用" class="headerlink" title="构造函数的作用"></a>构造函数的作用</h3><ul>
<li>JS中, 构造函数是给对象添加属性, 初始化属性用的</li>
<li><p>创建对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<ul>
<li>过程(以p对象创建为例):<ul>
<li>首先使用new关键字创建对象, 类似于使用{}, 此时创建的对象是没有内容的<ul>
<li>需要注意两点: <ul>
<li>使用new关键字创建的对象, 对象的类型就是创建这个对象使用的构造函数的函数名</li>
<li>使用{}创建的对象, 对象的类型一定是object, 相当于使用了<code>new Object()</code></li>
</ul>
</li>
</ul>
</li>
<li>使用构造函数为其初始化成员<ul>
<li>说明:<ul>
<li>在构造函数调用开始的时候, 有一个赋值操作, 也就是让this=刚创建出来的对象</li>
<li>在构造函数中, this就代表刚创建出来的对象</li>
</ul>
</li>
</ul>
</li>
<li>在构造函数中, 利用对象的动态特性, 为对象添加成员        </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于构造函数中return的补充说明"><a href="#关于构造函数中return的补充说明" class="headerlink" title="关于构造函数中return的补充说明"></a>关于构造函数中return的补充说明</h3><ul>
<li><p>构造函数中不需要return, 就会默认的return this</p>
</li>
<li><p>如果手动的添加return, 就相当于 return this</p>
</li>
<li><p>如果手动的添加return 基本类型; 无效, 还是保留原来 返回this</p>
</li>
<li><p>如果手动添加return null; 或return undefiend, 无效</p>
</li>
<li><p>如果手动添加return 对象类型; 那么原来创建的this就会被丢掉, 返回的是 return后面的对象</p>
</li>
</ul>
<p>​    </p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ul>
<li>定义:<br>每个构造函数在创建出来的同时, 系统会自动的给构造函数关联一个空对象, 这个对象就是原型; 写在原型中的属性和方法可以被构造函数创建出来的所有对象共享</li>
</ul>
<p><strong>注</strong>: 对象就是实例, 实例化就是创建对象的过程</p>
<h3 id="原型的使用"><a href="#原型的使用" class="headerlink" title="原型的使用"></a>原型的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例子:  构造函数: </span></div><div class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = “二哈”;</div><div class="line">    <span class="keyword">this</span>.color = “yellow”;</div><div class="line">&#125;</div><div class="line"><span class="comment">//  1. 动态向原型中添加方法</span></div><div class="line">Dog.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'汪汪'</span>) </div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> Dog();   <span class="comment">// 新创建的对象可以直接调用 添加的方法</span></div><div class="line"><span class="comment">// 2.可以直接替换原型对象</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">   eat : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(“吃”) &#125; , </div><div class="line">   play : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(“玩”) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Dog.prototype = obj </div><div class="line">d1.eat()  </div><div class="line">d2.play()</div></pre></td></tr></table></figure>
<ul>
<li>注意点:<ul>
<li>使用<code>对象.属性名</code>去获取对象属性时, 会先在自身中进行查找, 如果没有再去原型中查找</li>
<li>使用<code>对象.属性名</code>去设置对象属性时, 只会在自身进行查找, 如果有就修改, 没有就添加</li>
<li>一般情况下, 不会将属性放在原型中, 只会把方法放在原型中</li>
<li>在替换原型时, 替换之前创建的对象, 和替换之后创建的对象的原型不一致</li>
</ul>
</li>
</ul>
<h3 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h3><ul>
<li><p>原型的访问方式(获取原型对象)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">构造函数名.prototype</div></pre></td></tr></table></figure>
</li>
<li><p>对象去访问原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对象名.__proto__</div></pre></td></tr></table></figure>
</li>
<li><p>原型的constructor属性: 在原型对象中, 这个属性指向构造函数</p>
</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>定义:<br>对象有原型, 原型本身也是对象, 原型也有原型, 原型的原型也有原型, 这样构成链式结构, 这个结构就是原型链</li>
</ul>
<blockquote>
<p>变量的搜索原则:<br>  当我们用<code>对象名.属性名</code>去访问一个属性时:</p>
<ul>
<li>首先会在对象自身查找, 如果找到直接使用</li>
<li>如果没有找到, 去对象的原型中找, 如果找到直接使用</li>
<li>如果没有找到, 会继续去原型的原型中找, 依次类推, 如果找到直接使用</li>
<li>如果最终还是没有找到, 会找到null</li>
</ul>
<p>Object.prototype中包含:</p>
<ul>
<li>instanceOf : 对象1  instanceOf 类型1 <pre><code>判断 对象是否是指定的类型 (不准确)
 对象  instanceOf  构造函数
</code></pre><ul>
<li>作用 :  判断 后面的构造函数的原型  是否在 前面对象的原型链上</li>
<li>注 : 构造函数就是 类型 , 类型就是构造函数</li>
</ul>
</li>
<li>constructor : 在 原型中  用于指定和 该原型相关的那个构造函数</li>
</ul>
</blockquote>
<ul>
<li>hasOwnProperty  : 判断对象自身是否拥有指定的属性 (原型中的属性不是自身的属性) </li>
<li><p>in  : 判断对象自身 或者对象的原型链上是否拥有指定的属性</p>
</li>
<li><p>isPrototypeOf : 判断对象1 是否在对象2的原型链上</p>
</li>
<li><p>propertyIsEnumerable : 判断对象的成员 是否可被for – in 遍历 , 前提是该属性存在</p>
</li>
<li><p>toString()   toLocalString  : 将数据转换成字符串</p>
</li>
<li><p>valueOf()  : 在参与比较时 ,系统会自动调用该方法 进行求值;可以在创建对象时 自己重写valueOf方法 , 在后续将引用类型转值类型 ,即可使用 . 如果不能参与运算 , 则需要调用toString方法，获得结果之后再去运算</p>
</li>
</ul>
<ul>
<li><p>静态方法:<br>构造函数名.方法名()　如: Math.random()   Math.abs()<br>直接使用功能 , 没有开辟空间的必要</p>
</li>
<li><p>实例方法:<br>对象名.方法名   arr.push(“a”)<br>实例就是对象  数组 var arr = new Array(); 开辟空间 创建对象 ,可以存储数据</p>
</li>
</ul>
<h2 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h2><ul>
<li>简单的混入式继承</li>
<li>原型混入式继承</li>
<li><p>替换原型对象继承</p>
</li>
<li><p>经典继承:<br>如果希望一个对象的原型是另一个对象 , 必须通过构造函数为中介来实现<br>ES5 中 有一个方法 可以直接让 一个对象的原型是另一个对象(有兼容性问题)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 即:</span></div><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create( obj1 )     <span class="comment">// 创建一个obj对象, 原型 为obj1 , 静态方法</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>Object.create(原型对象) : 在方法的内部会创建一个空的对象 ,并且让创建的这个对象的原型为 参数传进来的这个原型对象</p>
<h3 id="创建函数的几种方式"><a href="#创建函数的几种方式" class="headerlink" title="创建函数的几种方式"></a>创建函数的几种方式</h3><ul>
<li>函数声明 : 字面量 –  function test() </li>
<li>函数表达式  var test = function(){}</li>
<li>构造函数 var test =new Function()  <ul>
<li>创建一个空的函数 , 括号内只能传字符串 , 可以传n个参数 ,最后一个是函数体 ; 且 Function 可以将 符合js 语法规范的字符串当做js代码执行</li>
</ul>
</li>
</ul>
<ul>
<li>es6新语法 : 反引号定义字符串 , 字符串可以随意换行</li>
<li><p>Function  可以把字符串当做js代码执行</p>
<pre><code>前提 : 字符串符合js语法规则 ;  函数要被声明
</code></pre></li>
<li><p>eval() 用法和Function一样     实际开发中用的少 , 因为存在安全问题  , 性能问题</p>
</li>
</ul>
<h2 id="完整原型链"><a href="#完整原型链" class="headerlink" title="完整原型链"></a>完整原型链</h2><ul>
<li>结论:<ul>
<li>所有的原型链最终都会指向Object.prototype</li>
<li>所有的函数 都是由Function构造函数创建出来的, 包括Function自己</li>
<li>Function和 Object 是js中最核心的类型</li>
<li>Function 构造函数的原型在Object对象的原型链上; Object构造函数的原型在Function对象的原型链上</li>
</ul>
</li>
</ul>
<h3 id="Function和Object的关系"><a href="#Function和Object的关系" class="headerlink" title="Function和Object的关系"></a>Function和Object的关系</h3><ul>
<li>Object的原型在Object对象和Function对象的原型链上</li>
<li>Function的原型 也在Object对象和Function对象的原型链上  </li>
</ul>
<h3 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>有name属性 : test.name  函数名</li>
<li>有length属性 : test.length  表示的是形参的个数</li>
<li><p>有caller属性 : test.caller 获取当前函数的调用者 , 如果是全局 输出null   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如: </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123; </div><div class="line">   test() </div><div class="line">&#125;  </div><div class="line">test2()  <span class="comment">//输出结果为test2函数</span></div></pre></td></tr></table></figure>
</li>
<li><p>内置对象(Function , Array , Math , Date , Object)的原型不能被覆盖, 但是可以动态加方法, 最好不要直接改变内置对象</p>
</li>
</ul>
<h1 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h1><ul>
<li>变量的起作用的范围</li>
</ul>
<h2 id="几种作用域"><a href="#几种作用域" class="headerlink" title="几种作用域"></a>几种作用域</h2><ul>
<li><p>函数作用域: js中函数会构成独立的作用域</p>
</li>
<li><p>块级作用域: 代码块的内部会构成独立的作用域(JavaScript中没有块级作用域)</p>
</li>
<li><p>词法作用域: 词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是所谓词法作用域</p>
<ul>
<li><p>注: 函数调用时, 回到代码书写的位置去找值</p>
<pre><code>在js中词法作用域规则:

函数允许访问函数外的数据.

整个代码结构中只有函数可以限定作用域.

作用域规则首先使用提升规则分析

如果当前作用规则中有名字了, 就不考虑外面的名字
</code></pre><p>  ​     </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">例子<span class="number">1</span>：</div><div class="line"></div><div class="line">  <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log( num );</div><div class="line">  &#125;</div><div class="line">  foo();</div><div class="line">  例子<span class="number">2</span>：</div><div class="line">  <span class="keyword">if</span> ( <span class="literal">false</span> ) &#123;</div><div class="line">      <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log( num ); <span class="comment">// undefiend</span></div><div class="line">  例子<span class="number">3</span>：</div><div class="line">  <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> num = <span class="number">456</span>;</div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log( num );</div><div class="line">      &#125;</div><div class="line">      func();</div><div class="line">  &#125;</div><div class="line">  foo();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>动态作用域: 变量的解析是变量的执行环境来进行解析的</p>
<ul>
<li>注: js中有词法作用域没有动态作用域   </li>
</ul>
</li>
</ul>
<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><h3 id="js代码的执行步骤"><a href="#js代码的执行步骤" class="headerlink" title="js代码的执行步骤"></a>js代码的执行步骤</h3><ol>
<li>预解析: Js代码在执行之前  会将代码中的变量的声明和函数的声明提升到当前作用域的顶部</li>
<li>执行js</li>
</ol>
<h3 id="变量和函数不能被提升的情况"><a href="#变量和函数不能被提升的情况" class="headerlink" title="变量和函数不能被提升的情况"></a>变量和函数不能被提升的情况</h3><ul>
<li>函数表达式 只会提升左边的变量</li>
<li>Function 的构造函数创建的函数</li>
<li>未使用var声明的变量不会被预解析</li>
</ul>
<p><strong>注意点</strong>:</p>
<ul>
<li>同名的函数，后面的会覆盖前面的</li>
<li>当出现变量声明和函数同名的时候，只会对函数声明进行提升，变量会被忽略(相当于直接把变量的var去掉)</li>
<li><p>条件式的函数不会被预解析 不提升 (一般不推荐在条件里面写函数)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">test() </div><div class="line"><span class="keyword">if</span> ( <span class="literal">true</span> ) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hahah'</span>) </div><div class="line">    &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>预解析是分段的: 预解析是分script标签 , 如果有多个script标签 ,是不会跨越的(会报错); 代码的执行不分段,即上面script标签中的代码可以在下面script中执行</p>
</li>
</ul>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ul>
<li>定义:  在js中函数可以构成独立的作用域 , 函数的内部 又可以定义函数 ,函数的内部 又可以有新的作用域 , 这样多次嵌套 , 就会构成一个作用域的链式结构 , 就是作用域链</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> num = <span class="number">456</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="images/06-1.png" alt="上面函数的图示"></p>
<h3 id="绘制作用域链的步骤"><a href="#绘制作用域链的步骤" class="headerlink" title="绘制作用域链的步骤"></a>绘制作用域链的步骤</h3><ul>
<li><p>看整个全局是一条链, 即顶级链, 记为 0 级链</p>
</li>
<li><p>看全局作用域中, 有什么变量和函数声明, 就以方格的形式绘制到 0 级练上</p>
</li>
<li><p>再找函数, 只有函数可以限制作用域, 因此从函数中引入新链, 标记为 1 级链</p>
</li>
<li><p>然后在每一个 1 级链中再次往复刚才的行为</p>
</li>
</ul>
<h3 id="变量的访问规则-搜索原则"><a href="#变量的访问规则-搜索原则" class="headerlink" title="变量的访问规则(搜索原则)"></a>变量的访问规则(搜索原则)</h3><ol>
<li>当要获取变量的值时 , 首先会在当前的作用域中查找对应变量 , 如果 找到直接使用 , </li>
<li>如果没找到 , 会去上一级作用域中查找 , 如果找到直接使用,</li>
<li>如果没有 , 依次类推 , 一直会找到全局为止 , 如果最后没有找到会报错</li>
<li>注意,同级的链不可混合查找</li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><p>特点 : 闭包会延长变量的生命周期 , 闭包中变量在函数执行完成后, 不会被销毁 , 会常驻内存 , 直到页面关闭</p>
</li>
<li><p>好处 : 可以通过闭包给函数内部的数据提供外界唯一的访问渠道 , 我们在通道中设置校验逻辑 , 以保证数据安全 ; 可代替 全部变量使用 , 更安全</p>
</li>
</ul>
<p><strong>注</strong>: 大量的闭包和全局变量会造成内存浪费 , 所以尽量避免使用</p>
<ul>
<li><p>怎样获取和设置函数内部变量的值:</p>
<pre><code>+ 函数内部的变量 , 外界是无法访问的 : 
+ 解决办法 : 通过闭包 给外界提供唯一操作函数内部数据的通道 , 我们可以在通道中 对数据进行验证 , 可保证数据的安全可以使用闭包来代替全局变量
</code></pre></li>
<li><p>异步 :  js是单线程的  同一时刻只能做一件事情</p>
<ul>
<li><p>Js代码的执行 分为主要任务和次要任务 , 代码在执行时会优先执行主要任务 , 主要任务完成后 , 再开始执行次要任务</p>
<ul>
<li>主要任务 : 写在js代码中的主逻辑</li>
<li><p>次要任务 : 定时器  ajax  事件</p>
<p><strong>注</strong> : 异步队列中的代码同时执行</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>语法错误 : 错误产生在预解析时 , 自调用函数 是一个表达式 , 表达式在程序执行时 会 计算结果 , 不会被预解析</p>
</li>
<li><p>闭包的基本结构(使用模型)</p>
<ul>
<li>写一个函数, 函数内定义一个新函数, 返回新函数, 用新函数获得函数内的数据</li>
<li>写一个函数, 函数内定义一个对象, 对象中绑定多个函数(方法), 返回对象, 利用对象的方法访问函数内的数据</li>
</ul>
</li>
</ul>
<h2 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h2><ul>
<li>在独立的空间中, 模拟现实的场景 , 沙箱和外界是隔离的 , 内外是互不影响的</li>
<li>js的沙箱模式是为了保护沙箱内部的数据不受外部的影响</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li><p>把数据临时存储起来, 以提高响应速度</p>
</li>
<li><p>缓存要存储多个数据 :  </p>
<ul>
<li>数组 <ul>
<li>优点 : 有索引 , 有顺序 , 存储多个数据</li>
<li>缺点 : 数组的索引时没有意义的 , 不方便取值</li>
</ul>
</li>
<li>对象 <ul>
<li>优点 : 对象的键是有意义的 , 方便取值</li>
<li>缺点 : 没有索引  没有顺序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h3><ul>
<li>浏览器缓存</li>
<li>cdn内容分发网络</li>
<li>硬件缓存(内存)</li>
<li>数据库缓存<ul>
<li>关系型 : mySql    orcale  把数据存在硬盘上</li>
<li>非关系型 : redies mongoDB 把数据存在内存中</li>
</ul>
</li>
</ul>
<h2 id="函数的调用模式"><a href="#函数的调用模式" class="headerlink" title="函数的调用模式"></a>函数的调用模式</h2><ul>
<li>在不同的调用模式下, this的指向是不同的, 在同一调用模式下, this的指向是相同的</li>
<li>在前三种调用模式中 this的指向是固定的, 不能被替换的, this都是右值, 不能被赋值和改变</li>
</ul>
<h3 id="四种调用模式"><a href="#四种调用模式" class="headerlink" title="四种调用模式"></a>四种调用模式</h3><ul>
<li>函数调用模式, 即普通调用(this指向window)</li>
</ul>
<p>this指向问题在canvas第一天中有详细说明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数名()</div></pre></td></tr></table></figure>
<ul>
<li>方法调用模式(this指向当前对象, 谁调用就指向谁)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对象中的函数称为方法</span></div><div class="line"><span class="comment">//对象名.方法名()</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;</div><div class="line">obj.say()</div></pre></td></tr></table></figure>
<ul>
<li>构造函数调用模式(this指向被new出来的新对象)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=<span class="string">"zf"</span>;</div><div class="line">  <span class="keyword">this</span>.age=<span class="number">20</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> test =<span class="keyword">new</span> Person()</div></pre></td></tr></table></figure>
<ul>
<li><p>上下文调用模式: 可以改变函数中this的指向</p>
<ol>
<li><p>函数名.call(对象, 参数1,参数2,参数3…)</p>
<ul>
<li>语法说明<ul>
<li>对象: 用于改变this指向的对象</li>
<li>参数1: 对应传递给前面函数作为第一个参数</li>
<li>参数2: 对应传递给前面函数作为第二个参数</li>
<li>参数n: 对应传递给前面函数作为第n个参数</li>
</ul>
</li>
</ul>
</li>
<li><p>函数名.apply(对象,[参数1,参数2,…])</p>
<ul>
<li><p>语法说明</p>
<ul>
<li>对象: 用于改变this指向的对象</li>
<li>伪数组参数:<ul>
<li>伪数组中第一个参数: 对应传递给前面函数作为第一个参数</li>
<li>伪数组中第n个参数: 对应传递给前面函数作为第n个参数</li>
</ul>
</li>
</ul>
<p><img src="images/11.png" alt="图示">   </p>
</li>
</ul>
<ul>
<li><p>call和apply的特殊情况: 对象是 数字 字符串 true null undefined<br><img src="images/12.png" alt="图示"></p>
</li>
<li><p>习题:<br><img src="images/13.png" alt="图示"></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/JS高级笔记/" data-id="cjfp5qsa40006pcx038kgjr0h" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS高级学习/">JS高级学习</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/07/Question笔记/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          Question笔记
        
      </div>
    </a>
  
  
    <a href="/2016/04/07/JS基础笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">JS基础笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">-笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bash学习/">bash学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/兼容性问题/">兼容性问题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/插件使用/">插件使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/遇到的问题/">遇到的问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">-学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BOM学习/">BOM学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM学习/">DOM学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/H5C3学习/">H5C3学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery学习/">JQuery学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS基础学习/">JS基础学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS高级学习/">JS高级学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Question学习/">Question学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/client、offset、scroll学习/">client、offset、scroll学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaScript/">javaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/兼容性问题（待更）/">兼容性问题（待更）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件使用（待更）/">插件使用（待更）</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/学习/" style="font-size: 20px;">-学习</a> <a href="/tags/BOM学习/" style="font-size: 10px;">BOM学习</a> <a href="/tags/DOM学习/" style="font-size: 10px;">DOM学习</a> <a href="/tags/H5C3学习/" style="font-size: 10px;">H5C3学习</a> <a href="/tags/JQuery学习/" style="font-size: 10px;">JQuery学习</a> <a href="/tags/JS基础学习/" style="font-size: 10px;">JS基础学习</a> <a href="/tags/JS高级学习/" style="font-size: 10px;">JS高级学习</a> <a href="/tags/Question学习/" style="font-size: 10px;">Question学习</a> <a href="/tags/client、offset、scroll学习/" style="font-size: 10px;">client、offset、scroll学习</a> <a href="/tags/javaScript/" style="font-size: 10px;">javaScript</a> <a href="/tags/兼容性问题（待更）/" style="font-size: 10px;">兼容性问题（待更）</a> <a href="/tags/学习/" style="font-size: 10px;">学习</a> <a href="/tags/插件使用（待更）/" style="font-size: 10px;">插件使用（待更）</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/08/面向对象/">bash</a>
          </li>
        
          <li>
            <a href="/2017/10/08/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/04/07/插件使用（待更）/">插件使用（待更）</a>
          </li>
        
          <li>
            <a href="/2016/04/07/兼容性问题（待更）/">兼容性问题（待更）</a>
          </li>
        
          <li>
            <a href="/2016/04/07/Question笔记/">Question笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>